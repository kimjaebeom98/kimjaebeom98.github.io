---
layout: single
title:  스티커 - 9465 
categories : BOJ
tag : [python, algorithm, BOJ]
toc : true
---


[문제 링크](https://www.acmicpc.net/problem/9465) 

### 분류

다이나믹 프로그래밍(dp)

### 문제 설명

<p>상근이의 여동생 상냥이는 문방구에서 스티커 2n개를 구매했다. 스티커는 그림 (a)와 같이 2행 n열로 배치되어 있다. 상냥이는 스티커를 이용해 책상을 꾸미려고 한다.</p>

<p>상냥이가 구매한 스티커의 품질은 매우 좋지 않다. 스티커 한 장을 떼면, 그 스티커와 변을 공유하는 스티커는 모두 찢어져서 사용할 수 없게 된다. 즉, 뗀 스티커의 왼쪽, 오른쪽, 위, 아래에 있는 스티커는 사용할 수 없게 된다.</p>

<p><img alt="" src="https://www.acmicpc.net/upload/images/sticker.png" style="height:150px; width:575px"></p>

<p>모든 스티커를 붙일 수 없게된 상냥이는 각 스티커에 점수를 매기고, 점수의 합이 최대가 되게 스티커를 떼어내려고 한다. 먼저, 그림 (b)와 같이 각 스티커에 점수를 매겼다. 상냥이가 뗄 수 있는 스티커의 점수의 최댓값을 구하는 프로그램을 작성하시오. 즉, 2n개의 스티커 중에서 점수의 합이 최대가 되면서 서로 변을 공유 하지 않는 스티커 집합을 구해야 한다.</p>

<p>위의 그림의 경우에 점수가 50, 50, 100, 60인 스티커를 고르면, 점수는 260이 되고 이 것이 최대 점수이다. 가장 높은 점수를 가지는 두 스티커 (100과 70)은 변을 공유하기 때문에, 동시에 뗄 수 없다.</p>

### 입력 

 <p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 n (1 ≤ n ≤ 100,000)이 주어진다. 다음 두 줄에는 n개의 정수가 주어지며, 각 정수는 그 위치에 해당하는 스티커의 점수이다. 연속하는 두 정수 사이에는 빈 칸이 하나 있다. 점수는 0보다 크거나 같고, 100보다 작거나 같은 정수이다. </p>

### 출력 

 <p>각 테스트 케이스 마다, 2n개의 스티커 중에서 두 변을 공유하지 않는 스티커 점수의 최댓값을 출력한다.</p>

### 풀이

**손으로 하나하나씩 실마리를 찾아가는 과정**
1. 어떤 스티커를 하나 선택했다면 인접한 상하좌우 칸의 스티커는 고를 수 없기 때문에 대체로 대각선에 있는 스티커를 고른다.

2. 하지만 한 열을 건너 뛰고 선택하는 게 최선인 경우도 있다. 이전 이전 열의 결과 값이, 이전 열의 결과 값보다 클 수 있다. `열 하나를 건너 뛰어 선택하는 경우 반드시 행을 바꾸게 된다.(같은 행을 고른다면 그 사이 열을 비워 둘 필요 없이 (대각선에 있는) 다른 쪽 행의 칸을 선택한다.)`

3. 두 개의 열을 건너 뛰는 것은 안된다. 왜냐하면 4개의 칸 중에 최소 하나 이상은 고를 수 있기 때문 그래서 안 더해주면 `낭비` 이다.  

**풀이 과정**

`n == 1` 
- 0열의 0행과 1행 중 max값을 선택하면 됨

`n == 2`
- 0행 0열 값 + 1행 1열 값 ,
1행 0열 값 + 0행 1열 값 중 max값을 선택

`n == 3`
- 0행 0열 값 + 1행 1열 값 + 0행 2열 값, 1행 0열 + 0행 2열 값 중 max값
1행 0열 값 + 0행 1열 값 + 1행 2열 값, 0행 0열 + 1행 2열 값 중 max값 중 max값을 선택  

`n >= 3`
- n == 3일 때와 마찬가지 반복 수행

### 코드
```python

t = int(input())

for _ in range(t):
    n = int(input())
    sticker = [list(map(int, input().split())) for _ in range(2)]

    if n == 1:
        print(max(sticker[0][0], sticker[1][0]))

    else:
        sticker[1][1] += sticker[0][0]
        sticker[0][1] += sticker[1][0]
        
        for i in range(2, n):
            sticker[0][i] += max(sticker[1][i-1], sticker[1][i-2])
            sticker[1][i] += max(sticker[0][i-1], sticker[0][i-2])
        
        print(max(sticker[0][n-1], sticker[1][n-1]))

```

:smile: