---
layout: single
title: 투 포인터(or Sliding window) ✔
categories : Algorithms
tag : [python, algorithm, BOJ]
toc : true
---

### 이론 ✌

1차원 배열이 있고, 이 배열에서 **각자 다른 원소를 가리키고 있는 2개의 포인터**를 조작해 가면서 원하는 것을 얻는 형태이다. 이 때문에 투 포인터 알고리즘으로 불린다.

N칸의 1차원 배열이 있을 때, 부분 배열 중 그 원소의 합이 M이 되는 경우의 수를 구하는 것이다. 모든 경우의 수를 다 테스트 해보면 구간 합을 구간 배열로 O(1)만에 구한다고 해도 경우의 수는 O(N^2)이므로 시간초과를 얻게 된다.


#### 예시 🔽
원소가 순서대로 N 이하 자연수 배열의 끝 까지 탐색하면서 합이 N이 될 경우의 수를 구합니다. start가 한 칸 이동하는 것은 구간에서 왼쪽 칸을 삭제하는 효과가 있고, end가 한 칸 이동하는 것은 구간에서 구간을 한 칸더 확장 시킨다는 효과가 있습니다. 같을 때는 경우의 수를 1 증가시키고, 구간을 확장할려고 end를 한 칸 이동시킵니다.

1. 먼저 포인터 2개 **start, end**를 준비한다. start는 앞 쪽, end는 뒤쪽의 인덱스이다 

2. (start, end) 구간의 합을 저장 할 sum을 준비한다. 

3. 이동원칙을 준수한다.

```python

sum > N : sum -= start, start += 1
sum < N : end += 1, sum += end
sum == N : count += 1, end += 1, sum += end

```
<hr/>

> N이하의 자연수 순서대로 이루어진 배열은 아니지만 그림 설명이 쉬울 것 같아서 퍼왔습니다.


Ex) M = 5인 경우를 살펴보자.

![img](https://mblogthumb-phinf.pstatic.net/20160824_56/kks227_1471976777631dvMpe_PNG/1.png?type=w2)

초기 상태이며, 빨간색 포인터 : start, 파란색 포인터 : end이다. S : 합.

**end**가 뒤로 움직일 때는 새로 포함한 원소를 S에 더하고, **start**가 뒤로 움직일 때는 새로 넘긴 원소를 S에서 빼는 식으로 현재 [start, end)의 합 S를 매번 쉽게 구할 수 있다.

![img](https://mblogthumb-phinf.pstatic.net/20160824_196/kks227_1471976777962Qks67_PNG/2.png?type=w2)

![img](https://mblogthumb-phinf.pstatic.net/20160824_274/kks227_1471976778508STsIS_PNG/3.png?type=w2)

![img](https://mblogthumb-phinf.pstatic.net/20160824_118/kks227_1471976778842HkF4H_PNG/4.png?type=w2)

처음에는 이렇게 end만 증가하게 된다. S가 계속 M보다 작기 때문! 마지막엔 S>=M이 되었으므로 아래와 같다.

![img](https://mblogthumb-phinf.pstatic.net/20160824_101/kks227_1471976779156aosTT_PNG/5.png?type=w2)

start를 한 칸 옮겼는데, 동시에 S = 5인 경우를 만났다. 이때 결과를 1 증가시켜 준다.

![img](https://mblogthumb-phinf.pstatic.net/20160824_186/kks227_1471976779456z8WVP_PNG/6.png?type=w2)

![img](https://mblogthumb-phinf.pstatic.net/20160824_1/kks227_1471976779887ko5yw_PNG/7.png?type=w2)

![img](https://mblogthumb-phinf.pstatic.net/20160824_265/kks227_1471976780291PDw0Y_PNG/8.png?type=w2)

![img](https://mblogthumb-phinf.pstatic.net/20160824_139/kks227_1471976780603hkxD5_PNG/9.png?type=w2)

![img](https://mblogthumb-phinf.pstatic.net/20160824_284/kks227_1471976780877YjQiA_PNG/10.png?type=w2)

![img](https://mblogthumb-phinf.pstatic.net/20160824_101/kks227_1471976781212P3Li0_PNG/11.png?type=w2)

![img](https://mblogthumb-phinf.pstatic.net/20160824_188/kks227_14719767815252r1eQ_PNG/12.png?type=w2)

이런 식으로 포인터들이 움직이게 된다. 여기서 2번째로 S = 5인 지점을 만났으므로 결과를 1 증가시켜 준다.

![img](https://mblogthumb-phinf.pstatic.net/20160824_80/kks227_14719767817475h0eo_PNG/13.png?type=w2)

그 직후, start가 1 증가하면서 start = end인 경우가 나온다.

![img](https://mblogthumb-phinf.pstatic.net/20160824_240/kks227_1471976782107sRHbv_PNG/14.png?type=w2)

![img](https://mblogthumb-phinf.pstatic.net/20160824_240/kks227_14719767826459iErQ_PNG/15.png?type=w2)

![img](https://mblogthumb-phinf.pstatic.net/20160824_192/kks227_1471976782977RS8E6_PNG/16.png?type=w2)

계속 가다 보면 세 번째로 S = 5인 지점을 만난다.

![img](https://mblogthumb-phinf.pstatic.net/20160824_147/kks227_1471976783270H1Bah_PNG/17.png?type=w2)

![img](https://mblogthumb-phinf.pstatic.net/20160824_44/kks227_1471976783607C4F3g_PNG/18.png?type=w2)

그 이후 조건에 맞춰 포인터를 증가시키다 보면, end가 배열 끝을 가리키게 되어 더이상 증가할 수 없는 상태가 된다.

![img](https://mblogthumb-phinf.pstatic.net/20160824_197/kks227_1471976784071FLqRR_PNG/19.png?type=w2)

![img](https://mblogthumb-phinf.pstatic.net/20160824_87/kks227_14719767845214em80_PNG/20.png?type=w2)

그렇게 되면 그냥 start만 증가시켜 가다가 start 역시 배열 끝에 다다르면 종료해도 되고, 그냥 그 자리에서 루프를 끝내버려도 된다. 이렇게 해서 S = 5인 경우는 3개 발견되었다.

**[그림설명링크](https://github.com/WooVictory/Ready-For-Tech-Interview/)**

<hr/>

### 백준 - 2018(수들의 합) 1️⃣

#### 문제 설명

<p>어떠한 자연수 N은, 몇 개의 연속된 자연수의 합으로 나타낼 수 있다. 당신은 어떤 자연수 N(1 ≤ N ≤ 10,000,000)에 대해서, 이 N을 몇 개의 연속된 자연수의 합으로 나타내는 가지수를 알고 싶어한다. 이때, 사용하는 자연수는 N이하여야 한다.</p>

<p>예를 들어, 15를 나타내는 방법은 15, 7+8, 4+5+6, 1+2+3+4+5의 4가지가 있다. 반면에 10을 나타내는 방법은 10, 1+2+3+4의 2가지가 있다.</p>

<p>N을 입력받아 가지수를 출력하는 프로그램을 작성하시오.</p>

#### 입력 

 <p>첫 줄에 정수 N이 주어진다.</p>

#### 출력 

 <p>입력된 자연수 N을 몇 개의 연속된 자연수의 합으로 나타내는 가지수를 출력하시오</p>

#### 풀이 🔓

위 설명과 같음

### 코드 📃

``` python
n = int(input())

start = 1
end = 1
s = 1
cnt = 0
# end가 n이라는 것은 끝에 도달
# 끝에 도달 한 경우는 남아 있는 start에서 end 까지 구간의 합이
# n보다 작다는 소리니깐 즉시 종료해줘도 됨
while end != n:
  # 현재 구간에서 한 칸 확장
  # 확장을 하고 확장된 칸을 더해줘야 의미가 있음
  if s < n:
    end+=1
    s+=end
  # 현재 구간에서 한 칸 삭제
  # 먼저 현재 구간에서 한 칸을 삭제해야 앞부분이 변경되는 효과
  elif s > n:
    s-=start
    start+=1
  else:
    cnt += 1
    end+=1
    s+=end

# 마지막 n은 무조건 포함이 되어야 하므로
print(cnt+1)

```
